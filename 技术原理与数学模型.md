# USB设备指纹识别系统 - 技术原理与数学模型

> **文档目的**: 为项目答辩准备，详细讲解USB指纹识别的技术原理和数学公式

---

## 目录

1. [系统概述与核心思想](#1-系统概述与核心思想)
2. [USB协议基础](#2-usb协议基础)
3. [特征提取算法](#3-特征提取算法)
4. [统计特征计算](#4-统计特征计算)
5. [相似度计算算法](#5-相似度计算算法)
6. [设备认证流程](#6-设备认证流程)
7. [系统性能分析](#7-系统性能分析)

---

## 1. 系统概述与核心思想

### 1.1 核心思想

USB设备指纹识别基于一个关键观察：**不同USB设备由于硬件控制器、固件实现的差异，在USB通信过程中表现出独特的时序特征**。

这些时序特征包括：
- **枚举阶段时间**: 设备插入后与主机协商配置所需的时间
- **数据传输时序**: 不同Endpoint的数据包间隔时间

### 1.2 系统架构

```
数据采集 → 特征提取 → 指纹生成 → 相似度计算 → 认证判定
   ↓           ↓           ↓           ↓           ↓
TShark    pyshark    统计算法    欧氏距离    阈值判断
```

### 1.3 物理层原理

USB设备的时序特征由以下因素决定：
- **硬件控制器**: 不同芯片厂商的控制器有不同的响应速度
- **固件实现**: 设备端的USB协议栈实现差异
- **晶振频率**: 影响设备的时钟精度
- **缓冲区管理**: 影响数据传输的批量处理

---

## 2. USB协议基础

### 2.1 USB传输类型

USB定义了四种传输类型：

| 传输类型 | 代码 | 用途 | 特点 |
|---------|------|------|------|
| Control | 0x02 | 控制命令 | 枚举阶段使用 |
| Bulk | 0x03 | 大量数据 | U盘数据传输 |
| Interrupt | 0x01 | 小量周期数据 | 键盘鼠标 |
| Isochronous | 0x00 | 实时数据流 | 音频视频 |

**本系统重点关注**: Control（枚举）和 Bulk（数据传输）

### 2.2 USB枚举过程

```
1. 设备插入
   ↓
2. 主机检测 → 发送 RESET 信号
   ↓
3. 获取设备描述符 (Control传输)
   ↓
4. 分配地址 (Control传输)
   ↓
5. 获取配置描述符 (Control传输)
   ↓
6. 设置配置 (Control传输)
   ↓
7. 枚举完成 → 开始 Bulk 传输
```

**关键观察**: 从最后一批Control传输到第一个Bulk传输的时间间隔，反映了设备的响应特性。

---

## 3. 特征提取算法

### 3.1 枚举特征提取

#### 3.1.1 算法描述

目标: 提取USB设备枚举阶段的时间特征

```
定义:
  T_control_last: 最后一个Control包的时间戳
  T_bulk_first: 第一个Bulk包的时间戳
  
枚举时间 = T_bulk_first - T_control_last
```

#### 3.1.2 实现伪代码

```python
enum_start_time = None
enum_end_time = None

for packet in capture:
    if packet.type == CONTROL:
        # 追踪最后的Control序列
        if enum_start_time is None or (packet.time - enum_start_time) > 2.0:
            enum_start_time = packet.time
    
    elif packet.type == BULK and enum_end_time is None:
        # 遇到第一个Bulk包
        enum_end_time = packet.time
        enum_duration = enum_end_time - enum_start_time
        
        # 有效性检查：合理范围 [0.01, 2.0] 秒
        if 0.01 < enum_duration < 2.0:
            return enum_duration
```

#### 3.1.3 数学模型

对于单个pcapng文件，枚举时间 $T_{enum}$ 定义为：

$$
T_{enum} = t_{bulk}^{(1)} - t_{control}^{(last)}
$$

其中：
- $t_{bulk}^{(1)}$: 第一个Bulk包的时间戳
- $t_{control}^{(last)}$: 最后一批Control包的起始时间戳

**有效性约束**:
$$
0.01s < T_{enum} < 2.0s
$$

### 3.2 传输特征提取

#### 3.2.1 算法描述

目标: 提取Bulk传输阶段的包间时间间隔（Inter-Packet Time, IPT）

对于每个Endpoint，计算连续数据包的时间间隔：

$$
\Delta t_i = t_{i+1} - t_i
$$

#### 3.2.2 Endpoint分组

USB设备有多个Endpoint，每个Endpoint代表一个逻辑通道：

```
Endpoint 1:   IN方向（设备→主机）
Endpoint 130: OUT方向（主机→设备）
Endpoint ... : 其他通道
```

**分组策略**: 按Endpoint地址分组，分别计算时间间隔

#### 3.2.3 实现伪代码

```python
transfer_data = defaultdict(list)  # {endpoint: [时间间隔列表]}
last_time = {}  # {endpoint: 上一个包的时间}

for packet in capture:
    if packet.type == BULK:
        endpoint = packet.endpoint_address
        timestamp = packet.sniff_timestamp
        
        if endpoint in last_time:
            # 计算与上一个包的时间差
            delta = timestamp - last_time[endpoint]
            
            # 过滤异常值
            if 0 < delta < 1.0:
                transfer_data[endpoint].append(delta)
        
        last_time[endpoint] = timestamp
```

#### 3.2.4 数学模型

对于Endpoint $e$，时间间隔序列为：

$$
\Delta T_e = \{\Delta t_1, \Delta t_2, ..., \Delta t_n\}
$$

其中：
$$
\Delta t_i = t_i^{(e)} - t_{i-1}^{(e)}
$$

**有效性约束**:
$$
0 < \Delta t_i < 1.0s
$$

---

## 4. 统计特征计算

### 4.1 基本统计量

对于任意时间序列 $X = \{x_1, x_2, ..., x_n\}$，计算：

#### 4.1.1 均值 (Mean)

$$
\mu = \frac{1}{n}\sum_{i=1}^{n} x_i
$$

**物理意义**: 反映设备的平均时序特性

#### 4.1.2 标准差 (Standard Deviation)

$$
\sigma = \sqrt{\frac{1}{n}\sum_{i=1}^{n} (x_i - \mu)^2}
$$

**物理意义**: 反映设备时序的稳定性，标准差越小说明设备越稳定

#### 4.1.3 样本数量 (Count)

$$
N = |X|
$$

**物理意义**: 统计置信度的基础

### 4.2 百分位数过滤

为了提高鲁棒性，对异常值进行过滤：

#### 4.2.1 百分位数定义

对于排序后的序列 $X_{sorted}$，第 $p$ 百分位数定义为：

$$
Q_p = X_{sorted}[\lceil n \cdot \frac{p}{100} \rceil]
$$

#### 4.2.2 过滤算法

设置过滤百分位数 $P = 5\%$：

$$
X_{filtered} = \{x \in X : Q_5 \leq x \leq Q_{95}\}
$$

**条件**: 仅当 $n \geq 10$ 时应用过滤，小样本保留所有数据

#### 4.2.3 实现代码

```python
def calculate_stats(data_list):
    arr = np.array(data_list)
    
    if len(arr) < 10:
        # 小样本不过滤
        clean_arr = arr
    else:
        # 大样本应用百分位数过滤
        lower = np.percentile(arr, 5)
        upper = np.percentile(arr, 95)
        clean_arr = arr[(arr >= lower) & (arr <= upper)]
    
    return {
        "mean": float(np.mean(clean_arr)),
        "std": float(np.std(clean_arr)),
        "count": len(clean_arr)
    }
```

### 4.3 指纹数据结构

设备指纹 $F$ 定义为：

$$
F = (F_{enum}, F_{transfer})
$$

其中：

**枚举指纹**:
$$
F_{enum} = (\mu_{enum}, \sigma_{enum}, N_{enum})
$$

**传输指纹**:
$$
F_{transfer} = \{(e, \mu_e, \sigma_e, N_e) : e \in Endpoints\}
$$

---

## 5. 相似度计算算法

### 5.1 归一化欧氏距离

#### 5.1.1 基本思想

使用**归一化的欧氏距离**来衡量两个特征的相似性。

对于两个特征 $F_1 = (\mu_1, \sigma_1)$ 和 $F_2 = (\mu_2, \sigma_2)$：

#### 5.1.2 数学公式

**步骤1: 计算均值差**

$$
\Delta \mu = |\mu_1 - \mu_2|
$$

**步骤2: 计算归一化因子**

使用两个标准差的平均值作为归一化因子：

$$
\bar{\sigma} = \frac{\sigma_1 + \sigma_2}{2}
$$

**步骤3: 计算归一化距离**

$$
d_{norm} = \frac{\Delta \mu}{\bar{\sigma}}
$$

**步骤4: 转换为相似度分数**

$$
S = \max(0, 100 - 10 \cdot d_{norm})
$$

其中：
- $S \in [0, 100]$: 相似度分数
- 当 $d_{norm} = 0$ 时，$S = 100$（完全相似）
- 当 $d_{norm} \geq 10$ 时，$S = 0$（完全不相似）

#### 5.1.3 物理解释

归一化距离 $d_{norm}$ 表示：**均值差距是标准差的多少倍**

- $d_{norm} < 1$: 差距小于1倍标准差，非常相似
- $d_{norm} \approx 2$: 差距约2倍标准差，较相似
- $d_{norm} > 5$: 差距超过5倍标准差，不相似

#### 5.1.4 实现代码

```python
def calculate_similarity(feature1, feature2):
    # 计算均值差
    diff = abs(feature1['mean'] - feature2['mean'])
    
    # 计算归一化因子
    std_avg = (feature1['std'] + feature2['std']) / 2
    if std_avg == 0:
        std_avg = 0.001  # 避免除零
    
    # 归一化距离
    normalized_diff = diff / std_avg
    
    # 转换为相似度分数
    similarity = max(0, 100 - normalized_diff * 10)
    
    return similarity
```

### 5.2 综合相似度计算

#### 5.2.1 特征权重

基于实验观察，我们为不同特征分配权重：

- **枚举特征权重**: $w_{enum} = 0.3$
- **传输特征权重**: $w_{transfer} = 0.7$

**原理**: 传输特征更稳定，样本量更大，因此给予更高权重

#### 5.2.2 综合相似度公式

对于认证样本 $A$ 和注册样本 $R$：

**枚举相似度**:
$$
S_{enum} = Similarity(F_{enum}^A, F_{enum}^R)
$$

**传输相似度集合**:
$$
S_{transfer} = \{s_e : e \in E_{common}\}
$$

其中 $E_{common}$ 是共同的Endpoint集合：
$$
E_{common} = E_A \cap E_R
$$

**传输平均相似度**:
$$
\bar{S}_{transfer} = \frac{1}{|E_{common}|} \sum_{e \in E_{common}} s_e
$$

**综合相似度**:
$$
S_{overall} = w_{enum} \cdot S_{enum} + w_{transfer} \cdot \bar{S}_{transfer}
$$

$$
S_{overall} = 0.3 \cdot S_{enum} + 0.7 \cdot \bar{S}_{transfer}
$$

#### 5.2.3 特殊情况处理

**情况1**: 只有枚举特征
$$
S_{overall} = S_{enum}
$$

**情况2**: 只有传输特征
$$
S_{overall} = \bar{S}_{transfer}
$$

**情况3**: 既无枚举也无传输特征
$$
S_{overall} = 0
$$

### 5.3 数值示例

假设有两个设备的特征：

**设备A（认证样本）**:
- 枚举: $\mu_A = 0.120s, \sigma_A = 0.015s$
- Endpoint 1: $\mu_A = 0.00067s, \sigma_A = 0.00012s$
- Endpoint 130: $\mu_A = 0.00089s, \sigma_A = 0.00015s$

**设备R（注册样本）**:
- 枚举: $\mu_R = 0.125s, \sigma_R = 0.020s$
- Endpoint 1: $\mu_R = 0.00065s, \sigma_R = 0.00010s$
- Endpoint 130: $\mu_R = 0.00091s, \sigma_R = 0.00014s$

**计算过程**:

1. **枚举相似度**:
   $$
   \Delta\mu = |0.120 - 0.125| = 0.005
   $$
   $$
   \bar{\sigma} = \frac{0.015 + 0.020}{2} = 0.0175
   $$
   $$
   d_{norm} = \frac{0.005}{0.0175} = 0.286
   $$
   $$
   S_{enum} = 100 - 10 \times 0.286 = 97.1\%
   $$

2. **Endpoint 1 相似度**:
   $$
   \Delta\mu = |0.00067 - 0.00065| = 0.00002
   $$
   $$
   \bar{\sigma} = \frac{0.00012 + 0.00010}{2} = 0.00011
   $$
   $$
   d_{norm} = \frac{0.00002}{0.00011} = 0.182
   $$
   $$
   s_1 = 100 - 10 \times 0.182 = 98.2\%
   $$

3. **Endpoint 130 相似度**: (类似计算)
   $$
   s_{130} = 98.6\%
   $$

4. **传输平均相似度**:
   $$
   \bar{S}_{transfer} = \frac{98.2 + 98.6}{2} = 98.4\%
   $$

5. **综合相似度**:
   $$
   S_{overall} = 0.3 \times 97.1 + 0.7 \times 98.4 = 98.0\%
   $$

**结论**: $98.0\% > 70\%$ (阈值)，认证通过 ✓

---

## 6. 设备认证流程

### 6.1 整体流程图

```
[采集认证样本] → [特征提取] → [数据库加载] → [逐设备匹配] → [判定]
       ↓              ↓             ↓              ↓            ↓
   pcapng文件    提取时序特征   加载指纹库    计算相似度   阈值判断
```

### 6.2 详细算法

#### 输入
- 认证样本集: $A = \{a_1, a_2, ..., a_m\}$ (pcapng文件)
- 指纹数据库: $DB = \{(id_i, F_i) : i = 1, ..., n\}$
- 阈值: $\theta = 70.0$

#### 输出
- 认证结果: $(result, matched\_id, score)$
  - $result \in \{True, False\}$
  - $matched\_id$: 匹配的设备ID
  - $score$: 最高相似度分数

#### 算法步骤

**步骤1**: 特征提取
```
For each file in A:
    Extract (T_enum, T_transfers)
    Aggregate into F_auth
```

**步骤2**: 逐设备比对
```
best_score = 0
best_id = None

For each (id_i, F_i) in DB:
    S_i = CalculateSimilarity(F_auth, F_i)
    
    If S_i > best_score:
        best_score = S_i
        best_id = id_i
```

**步骤3**: 判定
```
If best_score >= θ:
    return (True, best_id, best_score)
Else:
    return (False, best_id, best_score)
```

### 6.3 时间复杂度分析

- 特征提取: $O(m \cdot p)$，其中 $m$ 是文件数，$p$ 是平均包数
- 数据库加载: $O(n)$，其中 $n$ 是注册设备数
- 相似度计算: $O(n \cdot k)$，其中 $k$ 是平均Endpoint数
- **总复杂度**: $O(m \cdot p + n \cdot k)$

---

## 7. 系统性能分析

### 7.1 准确性分析

#### 7.1.1 影响因素

**正向因素**（提高准确性）:
1. 样本数量增加
2. 采集环境一致性
3. 设备时序稳定性

**负向因素**（降低准确性）:
1. 系统负载波动
2. USB端口差异
3. 环境噪声

#### 7.1.2 错误率估计

**False Positive Rate (误识率)**: 
- 定义: 将非法设备识别为合法设备的概率
- 控制: 提高阈值 $\theta$

**False Negative Rate (拒识率)**:
- 定义: 将合法设备识别为非法设备的概率
- 控制: 降低阈值 $\theta$，增加注册样本数

### 7.2 阈值选择

阈值 $\theta$ 的选择是准确率和召回率的权衡：

$$
Precision = \frac{TP}{TP + FP}
$$

$$
Recall = \frac{TP}{TP + FN}
$$

**推荐值**: $\theta = 70\%$ 
- 基于实验数据，同一设备相似度通常 > 85%
- 不同设备相似度通常 < 60%

### 7.3 鲁棒性优化

#### 7.3.1 百分位数过滤

通过去除极端值提高鲁棒性：

$$
Robustness\_Gain = \frac{\sigma_{filtered}}{\sigma_{raw}} < 1
$$

#### 7.3.2 多样本平均

增加样本数可降低随机误差：

$$
\sigma_{avg} = \frac{\sigma_{single}}{\sqrt{n}}
$$

其中 $n$ 是样本数量

---

## 8. 关键创新点

### 8.1 技术创新

1. **时序特征指纹化**
   - 首次将USB时序特征用于设备识别
   - 无需读取设备序列号等敏感信息

2. **归一化相似度算法**
   - 自适应标准差归一化
   - 对不同设备类型具有良好的泛化性

3. **分阶段特征提取**
   - 枚举阶段 + 传输阶段
   - 多维度特征融合

### 8.2 工程优化

1. **百分位数过滤**: 提高抗噪能力
2. **小样本处理**: 对样本量不足的情况特殊处理
3. **异步事件循环**: 解决Windows平台兼容性问题

---

## 9. 总结

### 9.1 核心公式总结

**特征统计**:
$$
\mu = \frac{1}{n}\sum_{i=1}^{n} x_i, \quad
\sigma = \sqrt{\frac{1}{n}\sum_{i=1}^{n} (x_i - \mu)^2}
$$

**相似度计算**:
$$
S = \max(0, 100 - 10 \cdot \frac{|\mu_1 - \mu_2|}{(\sigma_1 + \sigma_2)/2})
$$

**综合相似度**:
$$
S_{overall} = 0.3 \cdot S_{enum} + 0.7 \cdot \bar{S}_{transfer}
$$

**认证判定**:
$$
Authentication = \begin{cases}
True, & S_{overall} \geq \theta \\
False, & S_{overall} < \theta
\end{cases}
$$

### 9.2 答辩要点

1. **物理层原理**: USB硬件差异导致时序差异
2. **数学模型**: 归一化欧氏距离衡量相似性
3. **鲁棒性**: 百分位数过滤、多样本平均
4. **准确性**: 阈值可调、权重优化
5. **创新点**: 时序指纹、无需序列号

---

**文档版本**: 1.0  
**准备日期**: 2026-01-13  
**用途**: 项目答辩技术讲解
